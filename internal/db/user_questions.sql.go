// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: user_questions.sql

package db

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

const checkUserQuestionExists = `-- name: CheckUserQuestionExists :one
SELECT EXISTS(
  SELECT 1 FROM user_questions 
  WHERE user_id = $1 AND question_id = $2
) AS exists
`

type CheckUserQuestionExistsParams struct {
	UserID     int32
	QuestionID int32
}

func (q *Queries) CheckUserQuestionExists(ctx context.Context, arg CheckUserQuestionExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkUserQuestionExists, arg.UserID, arg.QuestionID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createUserQuestion = `-- name: CreateUserQuestion :one
INSERT INTO user_questions (
  user_id, question_id, is_solved, is_bookmarked, time_taken, incorrect
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING id, user_id, question_id, is_solved, is_bookmarked, time_taken, created_at, incorrect
`

type CreateUserQuestionParams struct {
	UserID       int32
	QuestionID   int32
	IsSolved     sql.NullBool
	IsBookmarked sql.NullBool
	TimeTaken    sql.NullInt32
	Incorrect    bool
}

func (q *Queries) CreateUserQuestion(ctx context.Context, arg CreateUserQuestionParams) (UserQuestion, error) {
	row := q.db.QueryRowContext(ctx, createUserQuestion,
		arg.UserID,
		arg.QuestionID,
		arg.IsSolved,
		arg.IsBookmarked,
		arg.TimeTaken,
		arg.Incorrect,
	)
	var i UserQuestion
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.QuestionID,
		&i.IsSolved,
		&i.IsBookmarked,
		&i.TimeTaken,
		&i.CreatedAt,
		&i.Incorrect,
	)
	return i, err
}

const getUserBookmarkedQuestions = `-- name: GetUserBookmarkedQuestions :many
SELECT 
  q.id,
  q.subject_id,
  q.question_text,
  q.difficulty_level,
  q.explanation,
  q.topic,
  q.subtopic,
  q.solve_rate,
  q.choices,
  q.correct_answer_index,
  q.created_at,
  q.passage,
  COUNT(*) OVER() AS total_count
FROM questions q
JOIN user_questions uq ON q.id = uq.question_id
WHERE uq.user_id = $1 AND uq.is_bookmarked = TRUE
ORDER BY 
  CASE 
    WHEN $2 = 'desc' THEN q.solve_rate * -1  -- Multiply by -1 for descending
    ELSE q.solve_rate
  END
`

type GetUserBookmarkedQuestionsParams struct {
	UserID  int32
	Column2 interface{}
}

type GetUserBookmarkedQuestionsRow struct {
	ID                 int32
	SubjectID          sql.NullInt32
	QuestionText       string
	DifficultyLevel    sql.NullInt32
	Explanation        sql.NullString
	Topic              sql.NullString
	Subtopic           sql.NullString
	SolveRate          sql.NullInt32
	Choices            []string
	CorrectAnswerIndex sql.NullInt32
	CreatedAt          sql.NullTime
	Passage            sql.NullString
	TotalCount         int64
}

func (q *Queries) GetUserBookmarkedQuestions(ctx context.Context, arg GetUserBookmarkedQuestionsParams) ([]GetUserBookmarkedQuestionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserBookmarkedQuestions, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserBookmarkedQuestionsRow
	for rows.Next() {
		var i GetUserBookmarkedQuestionsRow
		if err := rows.Scan(
			&i.ID,
			&i.SubjectID,
			&i.QuestionText,
			&i.DifficultyLevel,
			&i.Explanation,
			&i.Topic,
			&i.Subtopic,
			&i.SolveRate,
			pq.Array(&i.Choices),
			&i.CorrectAnswerIndex,
			&i.CreatedAt,
			&i.Passage,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserBookmarkedQuestionsAsc = `-- name: GetUserBookmarkedQuestionsAsc :many
SELECT 
  q.id,
  q.subject_id,
  q.question_text,
  q.difficulty_level,
  q.explanation,
  q.topic,
  q.subtopic,
  q.solve_rate,
  q.choices,
  q.correct_answer_index,
  q.created_at,
  q.passage,
  COUNT(*) OVER() AS total_count
FROM questions q
JOIN user_questions uq ON q.id = uq.question_id
WHERE uq.user_id = $1 AND uq.is_bookmarked = TRUE
ORDER BY q.solve_rate ASC
`

type GetUserBookmarkedQuestionsAscRow struct {
	ID                 int32
	SubjectID          sql.NullInt32
	QuestionText       string
	DifficultyLevel    sql.NullInt32
	Explanation        sql.NullString
	Topic              sql.NullString
	Subtopic           sql.NullString
	SolveRate          sql.NullInt32
	Choices            []string
	CorrectAnswerIndex sql.NullInt32
	CreatedAt          sql.NullTime
	Passage            sql.NullString
	TotalCount         int64
}

func (q *Queries) GetUserBookmarkedQuestionsAsc(ctx context.Context, userID int32) ([]GetUserBookmarkedQuestionsAscRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserBookmarkedQuestionsAsc, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserBookmarkedQuestionsAscRow
	for rows.Next() {
		var i GetUserBookmarkedQuestionsAscRow
		if err := rows.Scan(
			&i.ID,
			&i.SubjectID,
			&i.QuestionText,
			&i.DifficultyLevel,
			&i.Explanation,
			&i.Topic,
			&i.Subtopic,
			&i.SolveRate,
			pq.Array(&i.Choices),
			&i.CorrectAnswerIndex,
			&i.CreatedAt,
			&i.Passage,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserBookmarkedQuestionsDesc = `-- name: GetUserBookmarkedQuestionsDesc :many
SELECT 
  q.id,
  q.subject_id,
  q.question_text,
  q.difficulty_level,
  q.explanation,
  q.topic,
  q.subtopic,
  q.solve_rate,
  q.choices,
  q.correct_answer_index,
  q.created_at,
  q.passage,
  COUNT(*) OVER() AS total_count
FROM questions q
JOIN user_questions uq ON q.id = uq.question_id
WHERE uq.user_id = $1 AND uq.is_bookmarked = TRUE
ORDER BY q.solve_rate DESC
`

type GetUserBookmarkedQuestionsDescRow struct {
	ID                 int32
	SubjectID          sql.NullInt32
	QuestionText       string
	DifficultyLevel    sql.NullInt32
	Explanation        sql.NullString
	Topic              sql.NullString
	Subtopic           sql.NullString
	SolveRate          sql.NullInt32
	Choices            []string
	CorrectAnswerIndex sql.NullInt32
	CreatedAt          sql.NullTime
	Passage            sql.NullString
	TotalCount         int64
}

func (q *Queries) GetUserBookmarkedQuestionsDesc(ctx context.Context, userID int32) ([]GetUserBookmarkedQuestionsDescRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserBookmarkedQuestionsDesc, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserBookmarkedQuestionsDescRow
	for rows.Next() {
		var i GetUserBookmarkedQuestionsDescRow
		if err := rows.Scan(
			&i.ID,
			&i.SubjectID,
			&i.QuestionText,
			&i.DifficultyLevel,
			&i.Explanation,
			&i.Topic,
			&i.Subtopic,
			&i.SolveRate,
			pq.Array(&i.Choices),
			&i.CorrectAnswerIndex,
			&i.CreatedAt,
			&i.Passage,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserQuestion = `-- name: GetUserQuestion :one
SELECT id, user_id, question_id, is_solved, is_bookmarked, time_taken, created_at, incorrect
FROM user_questions
WHERE user_id = $1 AND question_id = $2
`

type GetUserQuestionParams struct {
	UserID     int32
	QuestionID int32
}

func (q *Queries) GetUserQuestion(ctx context.Context, arg GetUserQuestionParams) (UserQuestion, error) {
	row := q.db.QueryRowContext(ctx, getUserQuestion, arg.UserID, arg.QuestionID)
	var i UserQuestion
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.QuestionID,
		&i.IsSolved,
		&i.IsBookmarked,
		&i.TimeTaken,
		&i.CreatedAt,
		&i.Incorrect,
	)
	return i, err
}

const getUserQuestionByIDs = `-- name: GetUserQuestionByIDs :one
SELECT id, user_id, question_id, is_solved, is_bookmarked, time_taken, created_at, incorrect FROM user_questions
WHERE user_id = $1 AND question_id = $2
`

type GetUserQuestionByIDsParams struct {
	UserID     int32
	QuestionID int32
}

func (q *Queries) GetUserQuestionByIDs(ctx context.Context, arg GetUserQuestionByIDsParams) (UserQuestion, error) {
	row := q.db.QueryRowContext(ctx, getUserQuestionByIDs, arg.UserID, arg.QuestionID)
	var i UserQuestion
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.QuestionID,
		&i.IsSolved,
		&i.IsBookmarked,
		&i.TimeTaken,
		&i.CreatedAt,
		&i.Incorrect,
	)
	return i, err
}

const getUserQuestions = `-- name: GetUserQuestions :many
SELECT id, user_id, question_id, is_solved, is_bookmarked, time_taken, created_at, incorrect
FROM user_questions
WHERE user_id = $1
`

func (q *Queries) GetUserQuestions(ctx context.Context, userID int32) ([]UserQuestion, error) {
	rows, err := q.db.QueryContext(ctx, getUserQuestions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserQuestion
	for rows.Next() {
		var i UserQuestion
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.QuestionID,
			&i.IsSolved,
			&i.IsBookmarked,
			&i.TimeTaken,
			&i.CreatedAt,
			&i.Incorrect,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSolvedQuestions = `-- name: GetUserSolvedQuestions :many
SELECT 
  q.id,
  q.subject_id,
  q.question_text,
  q.difficulty_level,
  q.explanation,
  q.topic,
  q.subtopic,
  q.solve_rate,
  q.choices,
  q.correct_answer_index,
  q.created_at
FROM questions q
JOIN user_questions uq ON q.id = uq.question_id
WHERE uq.user_id = $1 AND uq.is_solved = TRUE
`

type GetUserSolvedQuestionsRow struct {
	ID                 int32
	SubjectID          sql.NullInt32
	QuestionText       string
	DifficultyLevel    sql.NullInt32
	Explanation        sql.NullString
	Topic              sql.NullString
	Subtopic           sql.NullString
	SolveRate          sql.NullInt32
	Choices            []string
	CorrectAnswerIndex sql.NullInt32
	CreatedAt          sql.NullTime
}

func (q *Queries) GetUserSolvedQuestions(ctx context.Context, userID int32) ([]GetUserSolvedQuestionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserSolvedQuestions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserSolvedQuestionsRow
	for rows.Next() {
		var i GetUserSolvedQuestionsRow
		if err := rows.Scan(
			&i.ID,
			&i.SubjectID,
			&i.QuestionText,
			&i.DifficultyLevel,
			&i.Explanation,
			&i.Topic,
			&i.Subtopic,
			&i.SolveRate,
			pq.Array(&i.Choices),
			&i.CorrectAnswerIndex,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markQuestionSolved = `-- name: MarkQuestionSolved :one
UPDATE user_questions
SET 
    is_solved = TRUE,
    time_taken = $3,
    incorrect = $4
WHERE user_id = $1 AND question_id = $2
RETURNING id, user_id, question_id, is_solved, is_bookmarked, time_taken, created_at, incorrect
`

type MarkQuestionSolvedParams struct {
	UserID     int32
	QuestionID int32
	TimeTaken  sql.NullInt32
	Incorrect  bool
}

func (q *Queries) MarkQuestionSolved(ctx context.Context, arg MarkQuestionSolvedParams) (UserQuestion, error) {
	row := q.db.QueryRowContext(ctx, markQuestionSolved,
		arg.UserID,
		arg.QuestionID,
		arg.TimeTaken,
		arg.Incorrect,
	)
	var i UserQuestion
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.QuestionID,
		&i.IsSolved,
		&i.IsBookmarked,
		&i.TimeTaken,
		&i.CreatedAt,
		&i.Incorrect,
	)
	return i, err
}

const toggleBookmark = `-- name: ToggleBookmark :one
UPDATE user_questions
SET is_bookmarked = NOT is_bookmarked
WHERE user_id = $1 AND question_id = $2
RETURNING id, user_id, question_id, is_solved, is_bookmarked, time_taken, created_at, incorrect
`

type ToggleBookmarkParams struct {
	UserID     int32
	QuestionID int32
}

func (q *Queries) ToggleBookmark(ctx context.Context, arg ToggleBookmarkParams) (UserQuestion, error) {
	row := q.db.QueryRowContext(ctx, toggleBookmark, arg.UserID, arg.QuestionID)
	var i UserQuestion
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.QuestionID,
		&i.IsSolved,
		&i.IsBookmarked,
		&i.TimeTaken,
		&i.CreatedAt,
		&i.Incorrect,
	)
	return i, err
}

const toggleSolved = `-- name: ToggleSolved :one
UPDATE user_questions
SET is_solved = NOT is_solved
WHERE user_id = $1 AND question_id = $2
RETURNING id, user_id, question_id, is_solved, is_bookmarked, time_taken, created_at, incorrect
`

type ToggleSolvedParams struct {
	UserID     int32
	QuestionID int32
}

func (q *Queries) ToggleSolved(ctx context.Context, arg ToggleSolvedParams) (UserQuestion, error) {
	row := q.db.QueryRowContext(ctx, toggleSolved, arg.UserID, arg.QuestionID)
	var i UserQuestion
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.QuestionID,
		&i.IsSolved,
		&i.IsBookmarked,
		&i.TimeTaken,
		&i.CreatedAt,
		&i.Incorrect,
	)
	return i, err
}

const updateUserQuestion = `-- name: UpdateUserQuestion :exec
UPDATE user_questions
SET is_solved = $3, incorrect = $4
WHERE user_id = $1 AND question_id = $2
`

type UpdateUserQuestionParams struct {
	UserID     int32
	QuestionID int32
	IsSolved   sql.NullBool
	Incorrect  bool
}

func (q *Queries) UpdateUserQuestion(ctx context.Context, arg UpdateUserQuestionParams) error {
	_, err := q.db.ExecContext(ctx, updateUserQuestion,
		arg.UserID,
		arg.QuestionID,
		arg.IsSolved,
		arg.Incorrect,
	)
	return err
}

const updateUserQuestionData = `-- name: UpdateUserQuestionData :one
UPDATE user_questions
SET 
    is_solved = $3,
    time_taken = $4,
    incorrect = $5
WHERE user_id = $1 AND question_id = $2
RETURNING id, user_id, question_id, is_solved, is_bookmarked, time_taken, created_at, incorrect
`

type UpdateUserQuestionDataParams struct {
	UserID     int32
	QuestionID int32
	IsSolved   sql.NullBool
	TimeTaken  sql.NullInt32
	Incorrect  bool
}

func (q *Queries) UpdateUserQuestionData(ctx context.Context, arg UpdateUserQuestionDataParams) (UserQuestion, error) {
	row := q.db.QueryRowContext(ctx, updateUserQuestionData,
		arg.UserID,
		arg.QuestionID,
		arg.IsSolved,
		arg.TimeTaken,
		arg.Incorrect,
	)
	var i UserQuestion
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.QuestionID,
		&i.IsSolved,
		&i.IsBookmarked,
		&i.TimeTaken,
		&i.CreatedAt,
		&i.Incorrect,
	)
	return i, err
}
