// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: user_questions.sql

package db

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

const createUserQuestion = `-- name: CreateUserQuestion :one
INSERT INTO user_questions (
    user_id, question_id, is_solved, is_bookmarked, time_taken
) VALUES (
    $1, $2, $3, $4, $5
)
ON CONFLICT (user_id, question_id) 
DO UPDATE SET
    is_solved = EXCLUDED.is_solved,
    is_bookmarked = EXCLUDED.is_bookmarked,
    time_taken = EXCLUDED.time_taken
RETURNING id, user_id, question_id, is_solved, is_bookmarked, time_taken, created_at
`

type CreateUserQuestionParams struct {
	UserID       int32
	QuestionID   int32
	IsSolved     sql.NullBool
	IsBookmarked sql.NullBool
	TimeTaken    sql.NullInt32
}

func (q *Queries) CreateUserQuestion(ctx context.Context, arg CreateUserQuestionParams) (UserQuestion, error) {
	row := q.db.QueryRowContext(ctx, createUserQuestion,
		arg.UserID,
		arg.QuestionID,
		arg.IsSolved,
		arg.IsBookmarked,
		arg.TimeTaken,
	)
	var i UserQuestion
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.QuestionID,
		&i.IsSolved,
		&i.IsBookmarked,
		&i.TimeTaken,
		&i.CreatedAt,
	)
	return i, err
}

const getUserBookmarkedQuestions = `-- name: GetUserBookmarkedQuestions :many
SELECT 
  q.id,
  q.subject_id,
  q.question_text,
  q.difficulty_level,
  q.explanation,
  q.topic,
  q.subtopic,
  q.solve_rate,
  q.choices,
  q.correct_answer_index,
  q.created_at
FROM questions q
JOIN user_questions uq ON q.id = uq.question_id
WHERE uq.user_id = $1 AND uq.is_bookmarked = TRUE
`

type GetUserBookmarkedQuestionsRow struct {
	ID                 int32
	SubjectID          sql.NullInt32
	QuestionText       string
	DifficultyLevel    sql.NullInt32
	Explanation        sql.NullString
	Topic              sql.NullString
	Subtopic           sql.NullString
	SolveRate          sql.NullInt32
	Choices            []string
	CorrectAnswerIndex sql.NullInt32
	CreatedAt          sql.NullTime
}

func (q *Queries) GetUserBookmarkedQuestions(ctx context.Context, userID int32) ([]GetUserBookmarkedQuestionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserBookmarkedQuestions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserBookmarkedQuestionsRow
	for rows.Next() {
		var i GetUserBookmarkedQuestionsRow
		if err := rows.Scan(
			&i.ID,
			&i.SubjectID,
			&i.QuestionText,
			&i.DifficultyLevel,
			&i.Explanation,
			&i.Topic,
			&i.Subtopic,
			&i.SolveRate,
			pq.Array(&i.Choices),
			&i.CorrectAnswerIndex,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserQuestionByIDs = `-- name: GetUserQuestionByIDs :one
SELECT id, user_id, question_id, is_solved, is_bookmarked, time_taken, created_at FROM user_questions
WHERE user_id = $1 AND question_id = $2
`

type GetUserQuestionByIDsParams struct {
	UserID     int32
	QuestionID int32
}

func (q *Queries) GetUserQuestionByIDs(ctx context.Context, arg GetUserQuestionByIDsParams) (UserQuestion, error) {
	row := q.db.QueryRowContext(ctx, getUserQuestionByIDs, arg.UserID, arg.QuestionID)
	var i UserQuestion
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.QuestionID,
		&i.IsSolved,
		&i.IsBookmarked,
		&i.TimeTaken,
		&i.CreatedAt,
	)
	return i, err
}

const getUserSolvedQuestions = `-- name: GetUserSolvedQuestions :many
SELECT 
  q.id,
  q.subject_id,
  q.question_text,
  q.difficulty_level,
  q.explanation,
  q.topic,
  q.subtopic,
  q.solve_rate,
  q.choices,
  q.correct_answer_index,
  q.created_at
FROM questions q
JOIN user_questions uq ON q.id = uq.question_id
WHERE uq.user_id = $1 AND uq.is_solved = TRUE
`

type GetUserSolvedQuestionsRow struct {
	ID                 int32
	SubjectID          sql.NullInt32
	QuestionText       string
	DifficultyLevel    sql.NullInt32
	Explanation        sql.NullString
	Topic              sql.NullString
	Subtopic           sql.NullString
	SolveRate          sql.NullInt32
	Choices            []string
	CorrectAnswerIndex sql.NullInt32
	CreatedAt          sql.NullTime
}

func (q *Queries) GetUserSolvedQuestions(ctx context.Context, userID int32) ([]GetUserSolvedQuestionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserSolvedQuestions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserSolvedQuestionsRow
	for rows.Next() {
		var i GetUserSolvedQuestionsRow
		if err := rows.Scan(
			&i.ID,
			&i.SubjectID,
			&i.QuestionText,
			&i.DifficultyLevel,
			&i.Explanation,
			&i.Topic,
			&i.Subtopic,
			&i.SolveRate,
			pq.Array(&i.Choices),
			&i.CorrectAnswerIndex,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markQuestionSolved = `-- name: MarkQuestionSolved :one
UPDATE user_questions
SET 
    is_solved = TRUE,
    time_taken = $3
WHERE user_id = $1 AND question_id = $2
RETURNING id, user_id, question_id, is_solved, is_bookmarked, time_taken, created_at
`

type MarkQuestionSolvedParams struct {
	UserID     int32
	QuestionID int32
	TimeTaken  sql.NullInt32
}

func (q *Queries) MarkQuestionSolved(ctx context.Context, arg MarkQuestionSolvedParams) (UserQuestion, error) {
	row := q.db.QueryRowContext(ctx, markQuestionSolved, arg.UserID, arg.QuestionID, arg.TimeTaken)
	var i UserQuestion
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.QuestionID,
		&i.IsSolved,
		&i.IsBookmarked,
		&i.TimeTaken,
		&i.CreatedAt,
	)
	return i, err
}

const toggleBookmark = `-- name: ToggleBookmark :one
UPDATE user_questions
SET is_bookmarked = NOT is_bookmarked
WHERE user_id = $1 AND question_id = $2
RETURNING id, user_id, question_id, is_solved, is_bookmarked, time_taken, created_at
`

type ToggleBookmarkParams struct {
	UserID     int32
	QuestionID int32
}

func (q *Queries) ToggleBookmark(ctx context.Context, arg ToggleBookmarkParams) (UserQuestion, error) {
	row := q.db.QueryRowContext(ctx, toggleBookmark, arg.UserID, arg.QuestionID)
	var i UserQuestion
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.QuestionID,
		&i.IsSolved,
		&i.IsBookmarked,
		&i.TimeTaken,
		&i.CreatedAt,
	)
	return i, err
}

const toggleSolved = `-- name: ToggleSolved :one
UPDATE user_questions
SET is_solved = NOT is_solved
WHERE user_id = $1 AND question_id = $2
RETURNING id, user_id, question_id, is_solved, is_bookmarked, time_taken, created_at
`

type ToggleSolvedParams struct {
	UserID     int32
	QuestionID int32
}

func (q *Queries) ToggleSolved(ctx context.Context, arg ToggleSolvedParams) (UserQuestion, error) {
	row := q.db.QueryRowContext(ctx, toggleSolved, arg.UserID, arg.QuestionID)
	var i UserQuestion
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.QuestionID,
		&i.IsSolved,
		&i.IsBookmarked,
		&i.TimeTaken,
		&i.CreatedAt,
	)
	return i, err
}
