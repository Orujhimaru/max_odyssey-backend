// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: questions.sql

package db

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

const getFilteredQuestions = `-- name: GetFilteredQuestions :many
SELECT 
    q.id, 
    q.subject_id, 
    q.question_text, 
    q.correct_answer_index,
    q.difficulty_level, 
    q.explanation, 
    q.created_at, 
    q.topic, 
    q.subtopic, 
    q.solve_rate, 
    q.choices, 
    q.passage, 
    q.bluebook, 
    q.html_table, 
    q.svg_image, 
    q.is_multiple_choice,
    COUNT(*) OVER() AS total_count,
    COALESCE(uq.is_solved, FALSE) as is_solved,
    COALESCE(uq.is_bookmarked, FALSE) as is_bookmarked,
    COALESCE(uq.incorrect, FALSE) as incorrect,
    uq.selected_option
FROM 
    questions q
LEFT JOIN 
    user_questions uq ON q.id = uq.question_id AND uq.user_id = $8
WHERE 
    ($1 = -1 OR q.subject_id = $1) AND
    ($2 = -1 OR q.difficulty_level = $2) AND
    ($3 = '' OR q.topic = $3) AND
    ($4 = '' OR q.subtopic = $4)
ORDER BY 
    CASE WHEN $5 = 'asc' THEN q.solve_rate END ASC,
    CASE WHEN $5 = 'desc' THEN q.solve_rate END DESC
LIMIT $6
OFFSET $7
`

type GetFilteredQuestionsParams struct {
	Column1 interface{} `json:"column_1"`
	Column2 interface{} `json:"column_2"`
	Column3 interface{} `json:"column_3"`
	Column4 interface{} `json:"column_4"`
	Column5 interface{} `json:"column_5"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
	UserID  int32       `json:"user_id"`
}

type GetFilteredQuestionsRow struct {
	ID                 int32          `json:"id"`
	SubjectID          sql.NullInt32  `json:"subject_id"`
	QuestionText       string         `json:"question_text"`
	CorrectAnswerIndex sql.NullInt32  `json:"correct_answer_index"`
	DifficultyLevel    sql.NullInt32  `json:"difficulty_level"`
	Explanation        sql.NullString `json:"explanation"`
	CreatedAt          sql.NullTime   `json:"created_at"`
	Topic              sql.NullString `json:"topic"`
	Subtopic           sql.NullString `json:"subtopic"`
	SolveRate          sql.NullInt32  `json:"solve_rate"`
	Choices            []string       `json:"choices"`
	Passage            sql.NullString `json:"passage"`
	Bluebook           bool           `json:"bluebook"`
	HtmlTable          sql.NullString `json:"html_table"`
	SvgImage           sql.NullString `json:"svg_image"`
	IsMultipleChoice   sql.NullBool   `json:"is_multiple_choice"`
	TotalCount         int64          `json:"total_count"`
	IsSolved           bool           `json:"is_solved"`
	IsBookmarked       bool           `json:"is_bookmarked"`
	Incorrect          bool           `json:"incorrect"`
	SelectedOption     sql.NullInt32  `json:"selected_option"`
}

func (q *Queries) GetFilteredQuestions(ctx context.Context, arg GetFilteredQuestionsParams) ([]GetFilteredQuestionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getFilteredQuestions,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Limit,
		arg.Offset,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFilteredQuestionsRow
	for rows.Next() {
		var i GetFilteredQuestionsRow
		if err := rows.Scan(
			&i.ID,
			&i.SubjectID,
			&i.QuestionText,
			&i.CorrectAnswerIndex,
			&i.DifficultyLevel,
			&i.Explanation,
			&i.CreatedAt,
			&i.Topic,
			&i.Subtopic,
			&i.SolveRate,
			pq.Array(&i.Choices),
			&i.Passage,
			&i.Bluebook,
			&i.HtmlTable,
			&i.SvgImage,
			&i.IsMultipleChoice,
			&i.TotalCount,
			&i.IsSolved,
			&i.IsBookmarked,
			&i.Incorrect,
			&i.SelectedOption,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuestion = `-- name: GetQuestion :one
SELECT id, subject_id, question_text, correct_answer_index, difficulty_level, explanation, 
       created_at, topic, subtopic, solve_rate, choices, passage, bluebook, html_table, svg_image, is_multiple_choice
FROM questions 
WHERE id = $1
`

type GetQuestionRow struct {
	ID                 int32          `json:"id"`
	SubjectID          sql.NullInt32  `json:"subject_id"`
	QuestionText       string         `json:"question_text"`
	CorrectAnswerIndex sql.NullInt32  `json:"correct_answer_index"`
	DifficultyLevel    sql.NullInt32  `json:"difficulty_level"`
	Explanation        sql.NullString `json:"explanation"`
	CreatedAt          sql.NullTime   `json:"created_at"`
	Topic              sql.NullString `json:"topic"`
	Subtopic           sql.NullString `json:"subtopic"`
	SolveRate          sql.NullInt32  `json:"solve_rate"`
	Choices            []string       `json:"choices"`
	Passage            sql.NullString `json:"passage"`
	Bluebook           bool           `json:"bluebook"`
	HtmlTable          sql.NullString `json:"html_table"`
	SvgImage           sql.NullString `json:"svg_image"`
	IsMultipleChoice   sql.NullBool   `json:"is_multiple_choice"`
}

func (q *Queries) GetQuestion(ctx context.Context, id int32) (GetQuestionRow, error) {
	row := q.db.QueryRowContext(ctx, getQuestion, id)
	var i GetQuestionRow
	err := row.Scan(
		&i.ID,
		&i.SubjectID,
		&i.QuestionText,
		&i.CorrectAnswerIndex,
		&i.DifficultyLevel,
		&i.Explanation,
		&i.CreatedAt,
		&i.Topic,
		&i.Subtopic,
		&i.SolveRate,
		pq.Array(&i.Choices),
		&i.Passage,
		&i.Bluebook,
		&i.HtmlTable,
		&i.SvgImage,
		&i.IsMultipleChoice,
	)
	return i, err
}

const getQuestions = `-- name: GetQuestions :many
SELECT id, subject_id, question_text, correct_answer_index, difficulty_level, explanation, 
       created_at, topic, subtopic, solve_rate, choices, passage, bluebook, html_table, svg_image, is_multiple_choice
FROM questions
`

type GetQuestionsRow struct {
	ID                 int32          `json:"id"`
	SubjectID          sql.NullInt32  `json:"subject_id"`
	QuestionText       string         `json:"question_text"`
	CorrectAnswerIndex sql.NullInt32  `json:"correct_answer_index"`
	DifficultyLevel    sql.NullInt32  `json:"difficulty_level"`
	Explanation        sql.NullString `json:"explanation"`
	CreatedAt          sql.NullTime   `json:"created_at"`
	Topic              sql.NullString `json:"topic"`
	Subtopic           sql.NullString `json:"subtopic"`
	SolveRate          sql.NullInt32  `json:"solve_rate"`
	Choices            []string       `json:"choices"`
	Passage            sql.NullString `json:"passage"`
	Bluebook           bool           `json:"bluebook"`
	HtmlTable          sql.NullString `json:"html_table"`
	SvgImage           sql.NullString `json:"svg_image"`
	IsMultipleChoice   sql.NullBool   `json:"is_multiple_choice"`
}

func (q *Queries) GetQuestions(ctx context.Context) ([]GetQuestionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getQuestions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetQuestionsRow
	for rows.Next() {
		var i GetQuestionsRow
		if err := rows.Scan(
			&i.ID,
			&i.SubjectID,
			&i.QuestionText,
			&i.CorrectAnswerIndex,
			&i.DifficultyLevel,
			&i.Explanation,
			&i.CreatedAt,
			&i.Topic,
			&i.Subtopic,
			&i.SolveRate,
			pq.Array(&i.Choices),
			&i.Passage,
			&i.Bluebook,
			&i.HtmlTable,
			&i.SvgImage,
			&i.IsMultipleChoice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
